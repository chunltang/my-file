抽象类：是对一类事物的抽象化，如形状是对三角形、原型等的抽象，抽象类中没有足够的信息来描述一个具体的对象（不能实列化），往往表示对问题领域进行分析、设计中得出的抽象概念，抽象类主要用来进行类型隐藏，为其他接口的实现提供辅助功能

抽象化（https://www.cnblogs.com/betterboyz/p/9361784.html）
　　从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征，就是抽象化。例如苹果、香蕉、生梨、 桃子等，它们共同的特性就是水果。得出水果概念的过程，就是一个抽象化的过程。要抽象，就必须进行 
    比较，没有比较就无法找到在本质上共同的部分。共同特征是指那些能把一类事物与他类事物区分开来的特征，这些具有区分作用的特征又称本质特征。因此抽取事物的共同特征就是抽取事物的本质特征，舍弃非本质的特征。 所以抽象化的过程也是一个裁剪的过程。在抽象时，同与不同，决定于从什么角度上来抽象。抽象的角度取决于分析问题的目的。
　　通常情况下，一组对象如果具有相同的特征，那么它们就可以通过一个共同的类来描述。如果一些类具有相同的特征，往往可以通过一个共同的抽象类来描述。


接口：它代表的是一个功能的集合，只有实现这个接口的类，它就具备这些功能，是一种has-a的关系，具有“某一项功能的意思”，就如手机既有播放器的功能，又有收音机的功能

列：如我需要一个闹钟叫我起床，但我没有闹钟，只有有闹钟功能的手机和一台有闹钟功能的洗衣机，我需要的只是闹钟功能，我管他是什么，只要他能让我起床就好了，如果某一天我的手机丢了，我能把洗衣机放到我的床边叫我起床吗？当然可以，因为洗衣机实现了闹钟的功能，我们

    把闹钟这个功能（而不是具体的某一事物，如手机或洗衣机）放在床边，如果我们想听洗衣机的闹钟声就摆洗衣机，如果想听手机就摆手机，我们传递的不是某个具体的对象，而是一个抽象的“闹钟功能”的概念，实际上我们只关心“具有闹钟功能”这件事，我们不关心她是由谁实现的和
	
	怎么实现的，这就做到了“请求”和“实现”分离开来，这就是接口的解耦！

抽象类定义的方法不需要全部实现（抽象方法都要实现），接口定义的方法需要全部实现，抽象类实现接口时，方法不一定需要实现

继承：是一种is-a的关系,手机是播放器、是收音机是错误的，所以使用手机继承播放器类时不对的，应该是要具有播放器的功能，是has-a的关系，只有一个方法操作的是类而非接口，那么你只能使用这个类及其子类了，如果你想将这个方法应用于不在此继承结构中的某个类，这是就麻烦了

final:方法和变量


面对对象的好处：可维护、可扩展、可复用、和灵活性好

PC电脑的硬件是易插播式的，面向对象叫强内聚、松耦合

面向对象总结：

    面向对象编程，并不是类越多越好，类的划分是为封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类，使用构造器的重载，实现参数不同，实列化不同的对象


设计模式的六大原则：

1.开闭原则(OCP)

对扩展开放，对修改关闭（接口和抽象类，实现一个热插拔的效果）  抽象化

开闭原则是说软件实体(类、模块、函数等) 应该可以扩展，但是不可以修改

2.里氏代换原则

面向对象设计的基本原则之一（任何基类出现的地方，子类一定可以出现，继承复用） 抽象化的具体实现

子类型必须能够替换掉他们的父类型

3.依赖倒转原则

开闭原则的基础，针对接口编程，依赖于抽象而不依赖于具体

抽象不应该依赖细节，细节应该依赖于抽象

针对接口编程，不要对实现编程

高层模块不应该依赖底层模块，两个都应该依赖抽象

依赖倒转其实就是谁也不要依赖谁，除了约定的接口，大家都可以灵活自如


4.接口隔离原则

使用多个隔离的接口，比使用单个接口好（降低类之间的耦合度） 降低依赖，降低耦合

5.迪米特法则（最少知道原则）

一个实体应当尽量少的和其他实体发生相互作用，使得系统功能模块相对独立

单一职责原则：就一个类而言，应该仅有一个引起它变化的原因，列：将逻辑处理委托给单一的类进行处理

强调在类的结构设计上，每一个类都应该尽量降低成员的访问权限，也就是说，一个类包装好自己的私有状态，不需要让别的类知道的字段或行为就不要公开，强调类之间的松耦合，类的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成搏击，

也即是说信息的隐藏促进了软件的复用

6.合成复用原则

尽量使用合成、聚合的方式，而不是使用继承


设计模式分为三大类：创建型模式、结构型模式、行为型模式


java的23种设计模式

1.工厂方法模式（factory method）--计算器的+、-、x、/

解决对象创建的问题

11.普通工厂模式

建立一个工厂类，对实现统一接口的一些类进行实列的创建

12.多个工厂方法模式

是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错则不能正确创建对象，多个工厂方法模式是提供多个工厂方法，分别创建对象

13.静态工厂方法模式

将工厂方法置为静态，不需创建实列，直接调用

工厂模式适合：凡是出现大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法来进行创建。多用静态工厂模式


2.抽象工厂模式

工厂模式有一个问题，类的创建依赖工厂类，如果需要扩展程序，必须对工厂类进行修改，这违背了闭包的原则。使用抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类即可，不需要修改之前的代码，一个工厂只生产一个类的实列


3.单列模式（Singleton）

单列对象能保证在一个JVM中，该对象只有一个实列存在

好处：某些类创建频繁，对于一些大型的对象，这是一笔很大的系统开销；省去了new操作符，降低系统内存的使用频率，减轻GC压力；有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了（一个军队只有一个司令指挥）


4.建造者模式（builder） 

工程类模式提供的是创建单个类的模式，建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，复合对象就是指某个类具有不同的属性

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，如游戏创建不同的小人，建造者模式又叫生成器模式

如果我们用了建造者模式，那么用户就只需要指定需要建造的类型就可以得到他们，而具体建造的过程和细节就不需要知道了

builder是为创建一个product对象的各个部件指定的抽象接口，指挥者，是构建一个使用Builder接口的对象，具体健造者，实现Builder接口，构造和装配各个部件

场景：主要用于创建一些复杂的对象，这些对象内部构造间的建造顺序通常是固定的，但对象内部的构建通常面临着复杂的变化

建造者模式的好处就是使建造代码和表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要在定义一个具体的建造者就可以了


5.原型模式（prototype）

将一个对象作为原型，对其进行复制、克隆、产生一个和原对象类似的新对象




6.适配器模式

将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题，主要分为类的适配器模式、对象的适配器模式、接口的适配器模式

类的适配器模式：使Targetable接口的实现具有Source类的功能

场合：当希望讲一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有类，实现新类的接口即可

接口的适配器模式：当接口的方法众多，写该接口的实现类时，必须实现该接口的所有方法，比较浪费。借助一个抽象类，实现该接口的所有方法，只和该抽象类打交道

场合：当不希望实现一个接口中所有的方法时


7.装饰模式(decorator)

功能：给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一接口，装饰对象持有被装饰对象的实列，子类继承装饰类，实现对装饰对象职责的扩展

动态地给一个对象添加以一些额外的职责，装饰模式比生成子类更为灵活

场景：需要扩展一个类的功能；动态的为一个对象添加功能，而且能动态撤销，继承不能做到这一点，继承的功能是静态的，不能动态增删；

缺点：产生过多相似对象，不易排错

灵活性性好，不用增加特别多的子类对原有功能进行扩展，降低系统耦合，面向接口编程，扩展性好


装饰模式和代理模式的区别：

但是把对象作为属性的就是装饰器模式了。那为什么接口作为属性就是代理模式呢？因为代理模式中的代理类的其实就是帮助任何实现了买票接口的对象进行买票行为。而如果是注释的代码的话，就变成了只对BuyTicket这个类的对象进行代理。那就变成了装饰器模式了。讲到这里应该明白了吧，其实关键就是在于接口（https://blog.csdn.net/u010102390/article/details/80658922）
装饰模式是对对象的代理，为实际对象。代理模式是对有统一行为的类的代理，代理对象为实现了同一接口的所有类。
如买票，装饰模式可以对小孩装饰，小孩不会买票，装饰扩展，帮小孩买票。(扩展的是实际对象)
代理模式，代理的是买票，如所有需要买票的人，我都可以帮他去买。(代理的是共同行为)


装饰模式意义在于对原有系统业务功能的扩展或者装饰，而代理模式常用在原有系统中增加一些与业务无关的操作，列如日志、验证功能等

装饰模式是对原有对象功能的扩展，操作对象是本身，代理模式是在对象不能、不方便操作某些操作的时候，代替去做某事，操作对象是代理类，并不了解原对象的实现细节

代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制，如何调用对象的某一功能是思考重点，而不是要兼顾对象的所有功能

装饰，偏重对原对象功能的扩展，扩展后的对象仍是对象本身，如何扩展对象的某一功能是思考重点


8.代理模式（proxy）

代理模式就是多一个代理类出来，替原对象做一些操作（如中介、律师），因为我可能对一些东西不了解，可以找人替我们进行操作

采用一个代理类调用原有的方法，且对生产的结果进行控制，可以将功能划分的更清晰，有助于后期维护

远程代理：为一个对象在不同地址空间提供局部代表，这样可以隐藏一个对象存在不同地址空间的事实，如webService，客户端程序调用代理就可以解决远程访问的问题，这就是代理模式的应用

虚拟代理：是根据需要创建开销很大的对象，通过它来存放实例化需要很长的时间的真实对象，如大型HTML网页，现加载所有文字，图片使用图片框代替，就是使用虚拟代理来替代真实的图片，此时代理存储了真实图片的路劲和尺寸，浏览器使用代理模式来优化下载的

安全代理：用来控制真实对象访问时的权限，一般用于对象应该有不同的访问权限的时候

智能指引：是指当调用真实的对象时，代理处理另外一些事，通过代理在访问一个对象时附加一些内部事务，如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它，或当第一次引用一个持久对象时，将它装入内存，或访问一个实际对象之前，检查是否已经锁定它

代理就是真实对象的代表



9.外观模式（facade）

是为了解决类与类之间的依赖关系的，像spring一样，可以将类与类之间的关系配置到配置文件中，外观模式就是将他们的关系放在一个Facade类中，降低类与类之间的耦合度，该模式没有涉及到接口

应用：首先，在设计初期阶段，应该要有意识的将不同的两个层分离，比如经典的三层架构，就需要考虑咋数据库访问层和业务逻辑层、业务逻辑层和表示层的层与层之间建立外观Facade，这样就可以为复杂的子系统提供一个简单的接口，使得耦合大大降低
   
      其次，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也会产生很多很小的类，这本就是好事，但也给外部调用他们的用户程序带来了使用上的困难，增加外观可以提供一个简单的接口，减少他们之间的依赖
	  第三，在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为它包含非常重要的功能，新的需求开发必须要依赖它，为新系统开发一个外观类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，facade与遗留代码交互锁有复杂的工作


10.桥接模式（bridge）

把事物和其具体实现分开，使他们可以各自独立的变化，桥接的用意是：将抽象化与实现解耦，使得二者可以独立变化

实列：JDBC和DriverManager，JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了


11.组合模式（composite）

组合模式又叫部分-整体模式，在处理类似树形结构的问题时比较方便


12.享元模式（flyweight）

主要实现对象的共享，即共享池（如数据库连接池），当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用

工厂负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果没有，则创建一个新对象，如果有，则返回已经存在的对象

适用于作共享的一些对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username,这些属性对于每个连接来说都一样，所以适合享元模式来处理，不需要每次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能




第三大类：行为型模式

1）通过父类和子类的关系进行实现  策略模式、模板方法模式

2）两个类之间  观察者模式、迭代子模式、责任链模式、命令模式

3）类的状态  备忘录模式、状态模式

4）通过中间类  访问者模式、中介者模式、解释器模式


13.策略模式（strategy）--商场促销的打折算法，算法本身是一种策略，最重要的是这些算法是随时都可以互相替换的，这就是变化点，二封装变化点是我们面向对象的一种重要的思维方式

策略模式定义一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户

策略模式封装了变化

场景：不同的时间应用不同的业务规则，考虑使用策略模式处理这种变化的可能性(变化点)

实现：需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类，提供辅助函数


14.模板方法模式（template method）

一个抽象类中，有一个主方法，在定义1...n个方法，可以是抽象的，也可以是实际的方法，在定义一个类继承该抽象方法，重写抽象的方法，在通过调用抽象类，实现对子类的调用，主方法即为模板方法

既然用了继承，就应该要成为子类的模板，所有重复的代码都应该上升到父类去，而不是让每个子类都去重复

定义抽象类，其实就是一个抽象模板，定义并实现一个模板方法，这个模板方法一般是一个具体的方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现，顶级逻辑也可能调用一些具体方法

模板方法就是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势，提取公共行为到抽象类中




15.观察者模式（observer） observer-subject

观察者模式又叫发布-订阅模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动跟新自己

当一个对象变化时，其他依赖该对象的对象都会受到通知，并且随着变化，对象之间是一种一对多的关系

观察者、通知者，都抽象出一个接口，通知者拥有观察者的集合和通知观察者的方法notify()，观察者有接收通知后的方法update()

观察者模式所做的工作其实就是解除耦合，让耦合的双方都依赖与抽象，而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化，也是依赖倒转原则的最佳体现

在通知者和观察者之间互相不知道，就由客户端来决定通知谁，即事件委托类

委托就是一种引用方法的类型，一旦为委托分配了方法，委托将与该方法具有完全相同的行为，委托方法的使用可以像其他任何方法，具有参数和返回值，委托可以看做是对函数的抽象，是函数的类，委托实列代表一个具体的函数，一个委托可以搭载多个方法，所有方法被依次唤起，它

可以使的委托对象所搭载的方法并不需要属于同一个类委托对象所搭载的所有方法必须拥有相同的参数列表和返回值类型


16.迭代子模式（iterator）

需要遍历的对象和迭代对象，用于对聚集对象进行遍历访问


17.责任链模式（chain of responsibility）

有多个对象，每个对象持有对下一个对象的引用


18.命令模式（command）

命令模式的目的就是达到命令的发出者和执行者之间的解耦，实现请求和执行的分开，struts就是一种将请求和呈现分离的技术


19.备忘录模式（memento）

主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象


20.状态模式（state）

当对象的状态改变时，同时改变其行为就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作

我们有时候希望根据对象的某一属性，区别开他们的一些功能，比如简单的权限控制等


21.访问者模式（visitor）

把数据结构和作用域数据结构上的操作解耦合，使得操作集合可相对自由的演化

访问者模式适用于数据结构相对稳定算法又易变化的系统，因为访问者模式使算法操作添加变得容易，若系统数据结构对象易于变化，经常有新的数据对象添加进来，则不适合适用访问者模式

分离数据结构与行为的方法，通过这种分离，可达到为一个访问者动态添加新的操作而无需做其他的修改的效果


22.中介者模式（mediator）

用来降低类类之间的耦合，如果类类之间有依赖的关系的话，补利于功能的拓展和维护，使用中介者模式，只需要关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用


23.解释器模式（interpreter）

解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等





java垃圾回收机制和IVM内存管理机制

1.垃圾回收并不会按照程序员的要求，随时进行GC

2.垃圾回收并不会及时清理内存，尽管有时程序需要额外的内存

3.程序员不能对垃圾回收进行控制


JVM内存结构

java虚拟机将内存分为几个不同的管理区，根据不同的特点，承担不同任务以及垃圾回收时运用不同的算法

部分：程序计数器（program counter register）、JVM虚拟机（JVM stacks）、堆（heap）、方法区（method area）



程序计数器：比较小的内存(有问题)，不咋Ram上，而是直接划分在CPU上，存储当前线程所执行的字节码的行号，字节码解释器工作时，就是通过改变程序计数器的值来选取下一条要执行的指令，每个线程都有一个独立的程序计数器，这类计数器为线程私有的内存，如果一个线程正在执行一个java

   方法，这计数器记录的是字节码的指令地址如果执行的是一个Native方法，则计数器的记录为空，此内存是唯一一个在java规范中没有任何OutOfMemoryError情况的区域
   
   

java虚拟机栈（JVM stacks）：

     java栈是java方法执行的内存模型，java栈中存放一个个栈侦，每个栈侦对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime 
	 constant pool)、方法返回地址(Return Address)和一些额外的附加信息。栈也是线程私有的。

     就是我们常说的堆栈的栈（把内存粗略分为堆和栈），线程私有的，每个方法被执行时产生一个栈侦，用于存储局部变量表、动态链接、操作数、方法出口等，方法的执行过程就是栈侦在JVM中出栈和入栈的过程，可能的异常：StackOverFlowErr、OutOfMemoryError

     局部变量表中存放的是各种基本数据类型，8中基本和引用类型（对象的地址），因此它有一个特点：内存空间可以在编译期间就确定，运行期不在改变。
   
   
   


本地方法栈（native method stacks）：就是用来处理java中的本地方法，java类祖先类Object中有众多Native方法，如hashCode(),wait()等，他们执行很多时候是借助于操作系统


堆（heap）

堆是内存中最重要的一块，因为java性能的优化，主要是针对这部分内存的。所有的对象实列及数组都是在堆上面分配的（随着JIT技术的成熟，这句话有点绝对），可通过-Xmx和-Xms来控制堆的大小，堆内存是垃圾回收的主要区域，32为系统上最大为2G，64位系统中无限制

    -Xms为JVM启动时申请的最小Heap内存，-Xmx为JVM可申请的最大Heap内存
	
	分为新生代(Eden Space，from survivor,to survivor,8:1:1)、老年代。新创建的对象的内存都是在新生代的Eden区分配，进过1到多次的GC后，剩下的对象被转移到老年代
	
	在gc开始之前，对象保存在eden、和survivor的from区，而survivor的to区是空的，当gc后，会将在eden区中保留的对象复制到to区，在from区中的对象会根据年龄决定去向，年龄超过阈值的复制到老年代，没超过的复制到to区，之后会清空eden区和from区，并交换from和to区的定义，
	
	即在gc后to区变为gc前的from区，gc前的from变为gc后的to区，最总保持to区为空，gc会一直进行这个过程，直到to区被填满后，会将所有对象转移到老年代中，复制的同时也要修改被拷贝内存的栈引用地址，而对from或者eden区域的大对象存储空间直接将其复制到老年代，因为大对象在from和to区多次复制的效率比较低，直接将其加入老年代中以提高回收效率
	

回收算法

  标记整理算法，复制算法，根搜索算法，引用计数算法
  
  jvm中gc执行的三种方式，即串行(gc效率高，但可能给应用带来停顿)，并行(gc和app两者的线程并发执行，对应用程序运行没有影响)，并发(多个线程执行gc，可以提高gc效率，但是算法复杂，系统消耗较大)
	
	
	

方法区（method area）

方法区是所有线程共享的内存区域，用于存储被JVM加载的类信息、常量、静态变量等数据，一般来说方法区属于持久代(持久代是方法区规范的一种实现)

运行时常量池：主要用于存放在编译过程中产生的字面量（字面量简单来说就是常量）和引用，已般情况，常量的内存分配在编译期间就能确定，但不一定全是，有一些就是运行时也可以将常量放入常量池中，如string类的Native方法intern()


直接内存：就是通过操作系统直接分配内存。一个在JVM内存管理之外的一个内存区，NIO类，基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，即我们说的直接内存，在某些场景中会提高程序的性能。



java垃圾回收（Garbage collection，GC）

随着程序的运行，内存中存在的实列对象、变量等信息占据的内存越来越多。


那些需要回收

三个区不需要进行垃圾回收：程序计数器、JVM栈、本地方法栈，应为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放，所以只有方法区和堆需要进行GC,如果对象已经不存在任何引用，那么它可以被回收


什么时候被回收

根据一个经典的引用计数算法，每个对象添加一个计数器，没被引用一次，计数器加1，失去引用，计数器减1，当计数器在一段时间内保持为0时，该对象可以被回收了

    缺陷：当两个对象相互引用时，对象失去作用后因相互持有二不能进行回收，因此Sun的JVM并没有采用引用计数法来进行垃圾回收
	

根搜索算法

基本思想：从一个GC Roots的对象开始向下搜索，如果一个对像不能到达GC Roots对象的时候，说明它已经不再被引用，即可被回收（当一个对象不再被引用时，并没有完全死亡，如果类重写了finalize()方法，且没有被系统调用，那么系统会调用一次finalize()方法，已完成最后的工作，）

   如果在这期间将对象重新与任何一个和GC Roots有引用的对象关联，则对象可以重生，如果不可以，则该对象彻底可以被回收了）
   
引用的概念：强、软、弱、虚四种引用


什么样的类需要回收

1.该类的所有实列对象都已经被回收

2.加载该类的ClassLoader已经被回收

3.该类对应的反射类java.lang.Class对象没有被任何地方引用


如何进行垃圾回收

垃圾回收算法

内存主要分为三块：新生代、旧生代、持久代，特点不同，所用的GC算法不同

新生代适合那些生命周期较短，频繁创建及销毁的对象，旧生代适合生命周期相对较长的对象，持久代在SunHotSpot中就是指方法区（有些JVM中根本没有持久代的说法）




java程序性能优化

1.gc()调用  System.gc()等效于Runtime.getRuntime().gc()   表示虚拟机已经尽最大努力从所有丢弃的对象中回收空间

2.finalize()的调用及重写  gc只能清除堆上分配的内存（纯java语言的所有对象都在堆上使用new分配内存），而不能清除栈上分配的内存，对栈上的对象进行内存回收就要靠finalize()


常见问题

1.内存溢出  要求分配的java虚拟机内存超出了系统能给你，系统不能满足要求，于是产生溢出

2.内存泄漏  



堆大小设置(堆=年轻代+年老代+持久代)

-server -Xmx1024m -Xms1024m

-Xmx 设置JVM最大可用内存为1024M

-Xms 设置JVM初始化内存为1024M，此值可以与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存，若果超过电脑内存则会报错，过小也会报错

-Xss128k 设置每个线程的堆栈大小(JDK5.0以后每个线程堆栈大小为1M)

-Xmn1024m 设置年轻代大小为1024M。

-XX：NewSize=1024m 设置年轻代初始值为1024M

-XX：MaxNewSize=1024m 设置年轻代最大值为1024M

JVM8.0已经没有持久代，若设置则会警告





================================================================================================================================================
                                                         ||  java  ||                                                              
================================================================================================================================================
1.lock 锁

http://www.justdojava.com/2019/07/10/java-wangzhe/#

ReentrantLock 是一个使用频率非常高的锁，支持重入性，能够对共享资源重复加锁，即当前线程获取该锁后再次获取时不会被阻塞。
ReentrantLock 既是公平锁又是非公平锁。调用无参构造方法时是非公平锁源码如下：

public ReentrantLock() {
    sync = new NonfairSync();
}

ReentrantLock 还提供了另外一种构造方法，源码如下：

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}

当传入 true 的时候为公平锁，false 的时候为非公平锁。
那公平锁和非公平锁到底有什么区别呢？
公平锁可以保证请求资源在时间上的绝对顺序，而非公平锁有可能导致其他线程永远无法获取到锁，造成“饥饿”的现象。
公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会减少一些上下文切换，性能开销相对较小，可以保证系统更大的吞吐量。


************************************************************************************************************************************************

2.内存泄漏与内存溢出

http://www.ityouknow.com/java/2019/05/23/memory-leak.html

内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。
有可能此对象已经不使用了，但是还有其它对象保持着此对象的引用，就会导致 GC 不能回收此对象，这种情况下就会出现内存泄漏。
写一个程序让出现内存泄漏:
长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。

public class Simple {
    Object object;
    public void method1(){
        object = new Object();
        //...其他代码
    }
}
这里的 object 实例，其实我们期望它只作用于 method1() 方法中，且其他地方不会再用到它，但是，当method1()方法执行完成后，
object 对象所分配的内存不会马上被认为是可以被释放的对象，只有在 Simple 类创建的对象被释放后才会被释放，严格的说，这就是一种内存泄露。

内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；
内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
所以内存泄漏可能会导致内存溢出，但内存溢出并不完全都是因为内存泄漏，也有可能使用了太多的大对象导致。


************************************************************************************************************************************************

3.解决HttpServletRequest的输入流只能读取一次的问题

解决前后端分离，获取POST请求体参数

https://blog.51cto.com/zero01/2334836

************************************************************************************************************************************************
4.NanoHTTPD

NanoHTTPD是一个免费、轻量级的(只有一个Java文件) HTTP服务器,可以很好地嵌入到Java程序中。支持 GET, POST, PUT, HEAD 和 DELETE 请求，支持文件上传，占用内存很小。

一般使用NanoHTTPD在Android上建立本地服务器

************************************************************************************************************************************************

5.java的byte和int转换

（https://blog.csdn.net/qq_35661171/article/details/78729262）
（https://www.cnblogs.com/ismileboy/p/7241567.html）

//一个字节是8位，一个int是32位，对于正数原码来说，反码和补码为原码本身
//对于负数来说，原码取反为反码，反码+1为补码
//一个字节是8位，转为int是32位，高位补充符号位，即正数高位补0，负数高位补1
//&0xFF作用是保持二进制补码的一致性，即高位都为0，地位保持不变
//16进制是2个字节，一个字节8位，0xFF和0x00FF是一样的，相当于高位补0

************************************************************************************************************************************************

6.Fork/Join框架详解

Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork/Join框架要完成两件事情：
1.任务分割：首先Fork/Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割
2.执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。





c++编译
  g++ -o name.out name.cpp;
  gcc -E name.cpp > test.p;
  
c++左值、右值、右值引用
  c++11中可以取地址的、有名字的就是左值，反之就是右值 int a=b+c;a为左值，b+c或函数返回值为右值，没有&(b+c);
  int &&a;为右值引用，其特点就是可以引用右值，右值一般指向的是临时变量，即即将被销毁的对象
  一般而言，左值可以是变量或者指定的可以更改的内存块，而右值是常量(列如const类型的量)或字面量(列如带双引号的字符串字面值或者直接数字)或者一些表达式
  作为一种追求执行效率的语言，c++再用临时对象或函数返回值给左值对象赋值时的深度拷贝一直受到诟病。考虑到临时对象的生命周期仅在表达式中持续，如果把临时对象的内容直接移动(move)给
  被赋值的左值对象，效率改善将是显著的，这就是移动语义的来源
  可以通过函数重载来确定是调用拷贝语义还是移动语义的实现，我们可以定义拷贝函数和赋值函数，实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符
  

关键字
  const：指定常量，表示只读类型，constexpr类似const但更强大，修饰函数或对象，表示函数结果或对象时编译器时决定的常量，以便优化
  const，volatile：是类型修饰符，合称cv-限定符，可以共同使用，用于变量或函数参数参数声明，也可限制非静态成员函数
  virtual：在基类中指定虚函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数，我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，
           这种操作称为动态链接，或者后期绑定
  char16_t,char32_t:分别表示16位字符型和32位字符型，类似char和wchar_t,也是一般只专用于表示字符的整数类型
  decltype：用于编译时推断类型
  nullptr:空指针常量
  static_assert:用于编译时的静态断言
  *_cast,const_cast，dynamic_cast,reinterpret_cast,static_cast:c++风格的类型转换
  goto：用于无条件跳转到函数类的标号
  struct,class,union:用于类型声明
  do,for,while,break,continue,goto,case,default,switch：循环组成部分
  bool,true,false:布尔类型
  delete，new：动态存储分配和释放
  double，float，long，int，short，signed，unsigned：数值类型，signed，unsigned作为前缀修饰整数类型，不可修饰wchat_t,char16_t,char32_t，期它整数类型默认为signed，从占用空间(sizeof)
        来看，char<=short<=int<=long<=long long
  enum:枚举类型的关键字
  explicit:修饰构造函数声明
  export:导出模板，用于分离编译
  extern:是存储类声明修饰符，表示外部链接
  friend：声明有元，使其不受访问权限控制的限制
  inline:声明定义内联函数(模板)，提示编译时内联--将所调用的代码嵌套到主调函数中
  mutable:用于类的非静态const数据成员，表示不受成员函数的const限制，可以在const成员函数中使用
  static：声明静态存储对象，或指定一个函数的名称具有内部链接，也可作用域类作用域的声明，表示声明的成员是类共有的，不需要通过类的对象访问，类的静态数据成员也具有静态存储期，除非被
         thread_local修饰
  sizeof：返回类型名或表达式具有的类型对应的大小，不能对函数使用
  this:this是一种实体，仅在类的非静态成员中使用，是指向类的对象的指针右值
  typedef：用来给数据类型取别名
  virtual:声明虚基类或虚函数，具有虚基类或虚函数的类是多态类
  typeid:获取表达式的类型
  typename：告诉编译器一个嵌套的限定名
  
  
c++存储类
  存储类定义了c++程序中变量/函数范围(可见性)和声明周期，这些说明符放置在他们所修饰的类型之前。
  auto(在c++11开始不在是说明符),static,extern,mutable,thread_local(c++11)
  
  auto:
  声明变量时根据初始化表达式自动推断该变量的类型，声明函数时函数返回值的占位符
  
  register：
  register存储类用于定义存储在寄存器中而不是RAM中的局部变量。这意味着变量的最大尺寸等于寄存器的大小，且不能对它用一元的‘&’运算符(因为它没有内存位置)
  寄存器只用于需要快速访问的变量，比如计数器，但只是可能存储在寄存器中，者取决于硬件和实现的限制。
  
  static：
  static存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要每次它进入和离开作用域是进行创建和销毁，因此，使用static修饰局部变量可以在函数调用之间保持局部变量的值
  static修饰符也可以应用于全局变量。当static修饰全局变量时，会使变量的作用域限制在声明它的文件内
  当static用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享
  可修饰全局变量和局部变量
  
  extern：
  extern存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的
  当使用extern时，对于无法初始化的变量，会把变量敏感指向一个之前定义过的存储位置
  extern是用来在另一个文件中声明一个全局变量或者函数，通常用于有两个或多个文件时共享相同的全局变量或函数的时候
  可用于数据和函数声明
  
  mutable：
  mutable存储类仅适用于类的对象，它允许对象的成员替代常量，也就是说，mutable成员可以通过const成员函数修改
  
  thread_local:
  适用thread_local说明的变量仅可在它在其上创建的线程访问，变量在创建线程是创建，并在销毁线程时销毁，每个线程都有其自己的变量副本
  只能用于数据声明不能用于函数声明
  
  
杂项运算符
  sizeof 返回变量的大小
  condition?x:y
  .(点)和->(箭头) 成员运算符用于引用类、结构和共用体成员
  Cast  强制转换运算符把一种数据类型转换为另一种数据成员  
  & 指针运算符，返变量的地址。列如&a;将给出变量的实际地址
  * 指向一个变量，列如：*var;将指向变量var
  
  
函数
  可以先声明，之后再定义函数主体
  函数调用：
  传值调用、指针调用、引用调用
  传值调用：该方法把参数的实际值复制给函数的形式参数，这种情况下，修改函数内的形式参数对实际参数没有影响
  指针调用：该方法把参数的地址复制给形式参数，在函数内，该地址用于访问调用中药用到的实际参数。者意味着，修改形式参数会影响实际参数
  引用调用：该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的形式参数，会影响实际参数。
  默认情况下，c++使用传值调用来传递参数
  参数的默认值：为参数列表中的每一个参数指定默认值，当调用函数时，如果实际参数的值留空，则使用默认值 int max(int a,int b=20)
  
  Lambda匿名函数：
  lambda表达式把函数看做对象，可以像对象一样使用，比如可以将他们赋值给变量和作为参数传递，还可以像函数一样对其求值。
  有返回值:[](int x,int y){return x<y;}
  无返回值：[]{++global_x;}
  指定返回值类型：[](int x,int y)->int {int z=x+y;return z+x;}
  如果lambda函数没有返回值，其返回类型可以完全忽略，在lambda表达式内可以访问当前作用域的变量，这是lambda表达式的闭包行为
  c++变量传递有传值和传引用的区别，可以通过前面的[]来指定：
      []没有定义任何变量，使用未定义变量会引发错误
      [x,&y]x已传值方式引入(默认),y已引用方式引入
      [&]任何被使用的外部变量都隐式地已引用方式加以引用
      [=]任何被使用的外部变量都隐式地已传值方式加以引用
	  [&,x]x显示的以传值方式加以引用，其余变量以引用方式加以引用
	  [=,&z]z显示的以引用方式加以引用，其余变量以传值方式加以引用
  对于[=]或[&]的形式,lambda表达式可以直接使用this指针，对于[]的形式，如果要使用this指针，必须显示传入:[this](){this->someFunc();}();
  
  
c++数字
  int,short,long.float和double等
  
  c++数学运算
  使用内置函数，需要引入头文件<cmath>
  
  c++随机数
  rand()返回一个伪随机数，生成随机数之前必须先调用srand()函数范围
  使用time()函数来获取系统时间的秒数
  
 
c++数组
  它可以存储一个固定大小的相同元素的顺序集合。
  所有的数组都是由连续的内存位置组成，最低的地址对应一个元素，最高的地址对应最后一个元素。
  数组声明:double balance[10]; 需要指定类型和数组长度
  数组初始化：double balance[10]={1.0,2.0}
  如果省略数组大小，则数组的大小则为初始化时元素的个数。
  指向数组的指针：可以通过制定不带索引的数组名称来生成一个指向数组中第一个元素的指针
  传递数组给函数：可以通过不带索引的数组名称来给函数传递一个指向数组的指针
  从函数返回数组：允许从函数返回数组
  
  
c++字符串
  c++提供了两种类型的字符串表示形式：c风格字符串，c++引入string类型
  字符串实际上是使用null字符'\0'终止的一维字符数组，char greeting[]="hello";  char greeting[6]={'H','e','l','l','o','\0'};
  c++有大量的函数来操作以null结尾的字符串：strcpy(s1,s2),stract(s1,s2),strlen(len),strcmp(s1,s2),strchr(s1,ch),strstr(s1,s2)
  
  c++中string类
  
  
c++指针
  通过指针，可以简化一些c++编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。
  每一个变量都有一个内存位置，每个内存位置都定义了可使用连字号(&)运算符访问的地址，它表示了在内存中的一个地址。
  &var1.&var2就是变量的内存地址
  
  什么是指针
  指针是一个变量，其值为另一个变量的地址，即内存位置的直接地址，就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明
  type *var-name type是指针的基类型，*用来声明一个变量使指针
  所有指针的值的实际数据类型，不管是整型、浮点型还是其他数据类型，都是一样的，都是一个代表内存地址的长的十六进制数
  不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同
  
  c++使用指针：
  定义一个指针变量、把变量地址复制给指针、访问指针变量中可用地址的值，这些是通过使用一元运算符*来返回位于操作数所指定地址的变量的值。
    #include <iostream>
	using namespace std;
	int main(){
	  int var = 20; //定义变量
	  int *ip;  //声明指针变量
	  ip=&var;  //将变量地址复制给指针变量
	  cout << "输出指针变量中存储的地址" << ip << endl; //访问指针变量，即指向变量的地址
	  cout << "访问指针中地址的值" << *ip << endl;   //访问指针中地址的值
	  return 0;
	}

  指向常量的指针vs常量指针：
  const出现在*左边，表示被指物是常量
  const出现在*右边，表示指针是常量，如果出现两遍*，表示被指物和指针都是常量
	
  c++指针详解
  c++Null指针，c++支持控指针，NULL指针是一个定义在标准库中的值为零的常量
  c++指针的算术运算，可以对指针进行四种算术运算：++、--、+、-
  c++指针vs数组，指针和数组之间有着密切关系
  c++指针数组，可以定义用来存储指针的数组
  c++指向指针的指针，c++允许指向指针的指针
  c++传递指针给函数，通过引用或地址传递参数，使传递的参数在调用函数中被改变
  c++从函数返回指针，c++允许函数返回指针到局部变量、静态变量和动态内存分配
  
  
c++引用
  引用变量使一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量
  
  c++引用vs指针
  引用和容易与指针混淆，他们之间有三个主要的不同：
  a.不存在空引用，引用必须连接到一块合法的内存
  b.一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
  c.引用必须在创建时初始化，指针可以在任何时间被初始化

 引用其实就是对象的别名，传对象的引用,用于把一个对象的地址作为参数传过去，而不是对象本身。
 传递引用，避免了一次实参到形参的拷贝，提高了效率。
 对于修改调用函数中数据的函数：
 如果数据对象是内置数据类型则使用指针。
 如果数据对象是数组则只能使用指针
 如果数据对象是结构则使用引用或指针
 如果数据对象是类对象则使用引用

在c/c++编程中，到底什么时候该用指针来传递参数呢？总结如下：
1. 需要改变实参的时候, 只能用指针.
2. 传递大型结构并且"只读"其元素的时候,因为大型结构通过值传递, 需要拷贝其每个元素, 这样效率太低.
3. 需要遍历数组或频繁引用其元素时, 这样效率比使用下标高.
4. 动态分配空间时, 必须使用指针.
5. 传递数组时, 必须使用指针.
6. 函数返回指针时, 比如fopen

使用引用参数的主要原因有：
  程序员能够修改调用函数中的数据对象
  通过传递引用而不是整个数据对象，可以提高运行速度

对于使用传递的值而不做修改的函数：
  如果数据对象很小，如内置数据对象，则按值传递
  如果数据对象是数组，则使用指针，并将指针声明为指向const的指针
  如果数据对象是较大的结构则使用const指针或const引用，以提高效率，节省复制结构所需的时间和空间
  如果数据对象是类对象则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因，因此传递类对象的标准方式是按照引用传递。

  c++中创建引用
  试想变量名称是变量附属在内存位置中的标签，您可以吧引用当成是变量附属在内存位置中的第二个标签，因此，可以通过原始变量名称或引用来访问变量的内容
  int i=17; int& r=i;  double& s=d;在这些声明中，&读作引用，因此，第一个声明可以读作‘r是一个初始化为i的整型引用’
  引用通常用于函数参数列表和函数返回值，两个与c++引用相关的重要概念：
  把引用作为参数，c++支持把引用作为参数传给函数，这比传一般的参数更安全
  把引用作为返回值，可以从c++函数中返回引用，就像返回其他数据类型一样
	
	
c++标准输入输出
  <iostream>,<iomanip>,<fstream>
  <iostream>定义了cin,cout,cerr,clog对象
  <iomanip>该文件通过所谓的参数化的流操纵器，比如setw和setprecision，来声明对执行标准化I/O有用的服务
  <fstream>该文件为用户控制的文件处理声明服务
  标准输出流(cout),是iostream类的一个实列，cout是与流插入运算符<<结合使用
  标准输入流(cin),cin是与流提取运算符>>结合使用
  标准错误流(cerr),cerr对象是非缓冲的，且每个流插入到cerr都会立即输出，cerr也是与流插入运算符<<结合使用的
  标准日志流(clog),clog对象时缓冲的，这意味着每个流插入到clog都会先存储在缓冲中，知道缓冲填满或者缓冲区刷新时才会输出，clog也是与流插入运算符<<结合使用
  
  
c++数据结构(有点类似java Bean)
  c++数组允许定义存储相同类型数据项的变量，但是结构是c++中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项，结构用于表示一条记录。
  定义结构：
  为了定义结构，您必须使用struct语句，struct语句定义了一个包含多个成员的新的数据类型
  访问结构成员：
  使用成员访问运算符(.)
  使用结构作为函数参数 void printBook(struct Book book);
  指向结构的指针  struct Books *struct_pointer;
  为了查找结构变量的地址，请把&运算符放在结构名称的前面：struct_pointer=&Book1;
  为了使用指向该结构的指针访问结构的成员，您必须使用->运算符：struct_pointer->title;
  
  typedef关键字
  可以为创建的类型取一个别名：typedef struct Books{}books; 现在可以直接使用books来定义Books类型的变量，而不需要使用struct关键字，books book1
  使用typedef来定义非结构类型，typedef long int *pint32; pint32 x,y,z;x,y和z都是指向长整形long int的指针
  
  
c++类
  类成员的访问权限：public、private(默认)、protected
  构造函数&析构函数：
  类的构造函数是一种特殊的函数，在创建一个新的对象时调用，类的析构函数也是一种特殊函数，在删除所创建的对象时调用
  c++拷贝构造函数：
  是一种特殊的构造函数，它在创建时，是使用同一类中之前创建的对象来初始化新的创建的对象
  c++友元函数：
  友元函数可以访问类的private和protected成员
  友元类不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。
  c++内联函数：
  通过内联函数，编译器视图在调用函数的地方扩展函数体中的代码
  c++中的this指针：
  每个对象都有一个特殊的指针this，它指向对象本身
  c++中指向类的指针：
  指向类的指针方式如同指向结构的指针，实际上，类可以看成是一个带有函数的结构
  c++类的静态成员：
  类的数据成员和函数成员都可以被声明为静态的
  
  
c++继承
  是多继承的
  派生类可以访问基类中所有的非私有成员，因此基类成员如果不想被派生类的成员函数访问，则应该在基类中声明为private
  一个派生类继承了所有的基类方法，但下列情况除外：
  基类的构造函数、析构函数和拷贝构造函数
  基类的重载运算符
  基类的友元函数
  
  继承类型：
  当一个派生自基类，该基类可以继承为public、private、protected，即继承过来成员的在派生类中的最大访问上限
  虚继承
  
 
c++重载运算符和重载函数
  c++允许在同一作用域中某个函数和运算符指定多个定义，分别称为函数重载和运算符重载
  重载的运算符是带有特殊名称的函数u，函数名是由关键字operator和其后要重载的运算符符号构成的，与其他函数一样，重载运算符有一个返回类型和参数列表 
  重载+号运算符：Box operator+(const Box&,const Box&);
  

c++多态
  当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态
  虚函数virtual：在基类中指定虚函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数，我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，
  这种操作称为动态链接，或者后期绑定
  纯虚函数：在基类中定义虚函数，当又不能对虚函数给出有意义的实现，则使用纯虚函数，列virtual int area()=0; =0告诉编译器，函数没有主题，上面的虚函数是纯虚函数
  
  
c++数据抽象
  数据抽象是指，只向外界提供关键信息，并隐藏后台的实现细节，即只表现必要的信息而不呈现细节，数据抽象是一种依赖接口和实现分离的编程设计
  访问标签强制抽象：
  我们使用访问标签来定义类的抽象接口，一个类可以包含零个或多个访问标签
  c++程序中，任何带有公有和私有成员的类都可以作为数据抽象的实列
  
  
c++数据封装
  封装是面向对象编程中的把数据操作数据的函数绑定在一起的一个概念，这样能避免受到外界干扰和误用，从而保证安全
  把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性
  
  
c++接口(抽象类)
  接口描述了类的行为和功能，而不需要完成类的特定实现，c++接口是使用抽象类来实现的
  如果类中的至少有一个函数被声明为纯虚函数，则这个类就是抽象类，纯虚函数是通过在声明中使用‘=0’来指定的
  设计抽象类(ABC)目的，是为了给其他类提供一个可以继承的适当的基类，抽象类不能被用于实列化对象，只能作为借口使用
  如果一个ABC类的子类需要被实列化，则必须实现每个虚函数
  面向对象的系统可能会使用一个抽象类为所有的外部应用程序提供一个适当的、通用的、标准化借口
  
  
c++文件和流
  使用ftream标准库，定义了三个新的数据类型，ofstream,ifstream,fstream
  ofstream:写操作,表示输出文件流，用于创建文件并向文件写入信息
  ifstream:读操作
  fstream：该数据类型通常表示文件流，且同时具有ofstream和ifstream的功能
  要在c++中处理文件，必须在包含头文件<iostream>,<fstream>
  打开文件：open(const *filename,ios::mode),5种打开模式，可以多种模式结合使用:
  ios::app,住家模式
  ios::ate,文件打开后定位到文件末尾
  ios::in,打开文件用于读取
  ios::out,打开文件用于写入
  ios::trunc,如果文件已存在，其内容将打开文件之前被截断，即把文件长度设为0
  关闭文件：close()当c++程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件
  写入文件：使用流插入运算符(<<)向文件写入信息
  文件位置指针：
  istream和ostream都提供了用于重新定位文件位置指针的函数，关于istream的seekg和ostream的seekp函数，第一个参数都是长整形，第二个参数用于指定查找方向
  查找方向可以是ios::beg(默认的，从流开始位置),ios::cur(从流当前位置),ios::end
  文件位置指针是一个整数型，指定了从文件起始位置到指针所在位置的字节数
  
  
c++异常处理
  涉及三个关键字：try,catch,throw
  抛出异常：
  可以使用throw语句在代码块中的任意地方抛出异常，throw语句的操作数可以是任意的表达式，表达式的结果的类型决定抛出的异常类型
  异常捕获：
  try {}catch(ExcepitonName e){}
  如果向catch块中能够处理try块中抛出的任何异常的类型，则在异常声明的括号类使用省略号try {}catch(...){}
  c++标准异常：
  c++提供了一系列标准的异常，定义在<exception>中，std::expection是所有标准的c++异常的父类
  自定义异常，通过继承和重载exception类,实现what方法，它已被所有子异常类重载，这将返回异常产生的原因
  
  
c++动态内存
  c++程序中的内存分为两个部分：
  栈：在函数内部声明的所有变量都将占用栈内存
  堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存
  很多时候，我们无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定
  在c++中，通过new运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址，如果您不需要动态分配的内存空间，可以使用delete运算符删除之前由new运算符分配的内存
  new和delete运算符：
  new data-type;在定义中data-type可以是包括数组在内的任意内置的数据类型，也可以是包括类和结构体在内的用户自定义的任何数据类型
  列：double* pvalue=NULL; pvalue=new double; 如果自由存储区已被用完，可能无法成功分配内存，所以建议检查new运算符是否返回NULL指针
      double* pvalue=NULL;
	  if(!(pvalue=new double)){
	    cout << "Error:out of memory." <<endl;
	    exit(1);
		}
  new与malloc()函数比较：
  malloc()函数在c语音中就出现了，在c++中任然存在，但不建议使用malloc()，new相比malloc()，其主要的优点是，new不只是分配了内存，还创建了对象。
  在任何时候，当您觉得某个已经动态分配的内存的变量不在需要使用时，您可以使用delete操作符释放它所占用的内存：
  delete pvalue; 释放pvalue锁指向的内存
  
  数组的动态内存分配：
  char* val=NULL;
  val=new char[20];
  delete [] val;
  一维数组：
  int *array=new int[m];
  delete [] array;
  二维数组：
  int **array;//为[m][n]数组动态分配内存
  array=new int *[m];
  for(int i=0;i<m;i++){
    array[i]=new int[n];
  }
  for(int i=0;i<m;i++){//释放
    delete [] array[i];
  }
  delete [] array;

  
c++命名空间
  命名空间的定义使用关键字namesapce，namespace name{}
  为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，name::code;code可以是变量或者函数
  命名空间可以嵌套，可以在多个文件中声明同一个命名空间
  
  
c++模板
  模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编程代码
  模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的列子，都使用模板的概念
  每个容器都有一个单一的定义，比如向量，我们可以定义许多不同类型的向量,比如vector<int>,vector<string>
  函数模板：
  template <class type> ret-type func-name(paramter list){函数主体},列：template <typename T> inline T const& Max(T const& a,T const& b){ return a<b?b:a;}
  类模板：
  template <class type> class class-name{},可以使用一个逗号分隔的列表来定义多个泛型数据类型
  
  
c++预处理器
  预处理器是一些指令，指示编译器在实际编译之前所需要完成的预处理
  所有的预处理器指令都是井号(#)开头，只有空格字符可以出现在预处理指令之前，预处理不是c++语句，所以他们不会已分号结尾
  #include：用于把头文件包含到源文件中
  #define：用于创建符号常量，该符号常量通常称为宏，#deifne PI 3.14159，当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都会在程序编译之前被替换为这个定义的值
  参数宏：
  #define MIN(a,b)(a<b?a:b)
  条件编译：
  有几个指令可以用来有选择的对部分程序源代码进行编译，条件预处理器的结构与if选择结构很像
  #ifdef NULL
    #define NULL 0
  #endif
  可以使用#if 0 语句注释掉程序的一部分：
  #if 0
    不进行编译的代码
  #endif
  #和##运算符：
  #运算符把text令牌转换为用引号引起来的字符串：
  #define MKSTR(x) #x 
  cout << MKSTR(HELLO C++) << endl; c++预处理器把MKSTR(HELLO C++)替换为“HELLO C++”
  #define CONCAT(x,y) x ## y
  当CONCAT出现带程序中时，它的参数会被连接起来，并用来取代宏，列如程序中的CONCAT(HELLO,C++)会被替换为“HELLO C++”
  int xy=100;
  cout << concat(x,y);会转化为cout << xy;
  
  c++中预定宏
  __LINE__:程序编译时包含当前行号
  __FILE__：程序编译时包含当前文件名
  __DATE__：把源文件转换为目标代码的日期
  __TIME__：程序被编译的时间
  
  
c++信号处理
  信号是由操作系统传给进程的中断，会提早终止一个程序，有些信号不能被程序捕获，但是下列所列信号可以在程序中捕获，并可以基于信号采取适当的动作，这些信号定义在<csignal>中string类
  信号：
  SIGABRT:程序的异常终止，如调用abort
  SIGFPE：错误的算术运算，比如除以零或者导致溢出的操作
  SIGILL：检测非法指令
  SIGINT:接收到交互注意信号
  SIGSEGV:非法访问内存
  SIGTERM:发送到程序的终止请求
  signal()函数：
  c++信号处理库提供了signal(),用来捕获突发事件，第一个参数是整数，代表信号编号，第二个参数是一个指向信号处理函数的指针
  不管想在程序中捕获什么信号，都必须使用signal函数来注册信号，并将其余信号处理程序关联
  raise()函数：
  可以使用函数raise()生成信号，该函数带有一个整数信号编号为参数：int raise(signal sig);
  
  
c++多线程
  创建线程：
  <pthread.h>
  pthread_create(thread,attr,start_routine,arg);参数依次是创建线程的id，线程参数，调用的函数，传入函数的参数
  终止线程：
  pthread_exit(status)
  pthread_exit用于显示的退出一个线程，如果main()是在它所创建的线程之前结束，并通过pthread_exit()退出，那么其他线程就继续执行。否则他们将在main结束时自动被终止
  连接和分离线程：
  pthread_join(threadid,status)
  pthread_detach(threadid)
  pthread_join子程序阻塞调用程序，直到指定的threadid线程终止为止，当创建一个线程时，它的某个线程属性会定义它是否是可连接的或可分离的
  
  
c++STL
  c++STL(标准模板库)是一套强大的c++模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。
  c++标准模板库的核心包括以下三个组件：
  容器：容器是用来管理某一类对象的集合，比如deque,list,vector,map等
  算法：算法作用域容器，他们提供了执行各种操作的方式，包括容器内容执行初始化、排序、搜索和转换等操作
  迭代器：迭代器用于遍历对象集合的元素，这些集合可能是容器，也可能是容器的子集
  这是哪个组件都带有丰富的的预定义函数，帮助我们通过简单的方式处理复杂的任务
  c++中的两种类型的容器：顺序容器和关联容器，顺序容器主要有vector,list,deque,其中vector表示一段连续的内存地址，基于数组的实现，list表示非连续的内存，基于链表的实现，内部数据结构为
  双向环状链表，不能随机访问一个元素，可双向遍历，deque和vector类似，但对于首元素提供了删除和插入的双向支持；关联容器主要有map和set，set和map只能存放唯一的key值，multimap和multiset
  可以存放多个相同的key值，map会根据键自动排序，set集合是有序的容器，默认都是升序排列，支持插入，删除，查找等操作，所有操作都是严格的在logn时间完成，效率非常高
  容器类自动申请和释放内存，我们所需new和delete操作
  
  
 
c++标准库
  分为两部分：
  标准函数库：这个库是由通用的、独立的、不属于任何类的函数组成，函数库继承自C语言。
  面向对象类库：这个库是类和相关函数的集合
  c++标准库包含了所有c标准库，为了支持类型安全，做了一定的添加和修改
  
  标准函数库：
  输入、输出I/O
  字符串和字符处理
  数学
  时间、日期和本地化
  动态分配
  其他
  宽字符函数
  
  面向对象类库：
  标准的c++I/O类
  String类
  数值类
  STL容器类
  STL算法
  STL函数对象
  STL迭代器
  STL分配器
  本地化库
  异常处理类
  杂项支持库